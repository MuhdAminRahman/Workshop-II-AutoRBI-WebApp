{% extends 'base.html' %}

{% block title %}Extract Equipment - {{ work.name }} - AutoRBI{% endblock %}

{% block content %}
<div class="extraction-page">
    <!-- Page Header -->
    <div class="mb-4">
        <h2 class="fw-bold">
            <i class="bi bi-file-earmark-arrow-up"></i> Extract Equipment Data
        </h2>
        <p class="text-muted">Upload GA drawing PDF to extract equipment information</p>
    </div>

    <!-- Work Info -->
    <div class="alert alert-info mb-4">
        <div class="d-flex align-items-center">
            <i class="bi bi-info-circle-fill fs-4 me-3"></i>
            <div>
                <strong>Work: {{ work.name }}</strong>
                <p class="mb-0 small">Upload a GA (General Arrangement) drawing PDF file. The system will automatically extract equipment data using AI. After extraction, you'll review and edit the data in table format.</p>
            </div>
        </div>
    </div>

    <!-- Quick Stats (if equipment exists) -->
    {% if equipment %}
    <div class="card border-0 shadow-sm mb-4 border-success" style="border-width: 2px !important;">
        <div class="card-header bg-success text-white">
            <h5 class="mb-0">
                <i class="bi bi-check-circle-fill"></i> Equipment Data Available
            </h5>
        </div>
        <div class="card-body">
            <div class="row text-center g-3">
                <div class="col-md-6">
                    <div class="stat-item">
                        <i class="bi bi-gear-fill text-primary fs-2"></i>
                        <h3 class="mb-0 mt-2">{{ equipment|length }}</h3>
                        <small class="text-muted">Equipment Items</small>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="stat-item">
                        <i class="bi bi-box text-success fs-2"></i>
                        <h3 class="mb-0 mt-2">
                            {% set total_components = namespace(count=0) %}
                            {% for equip in equipment %}
                                {% set total_components.count = total_components.count + (equip.components|length) %}
                            {% endfor %}
                            {{ total_components.count }}
                        </h3>
                        <small class="text-muted">Components Extracted</small>
                    </div>
                </div>
            </div>
            <div class="text-center mt-4">
                <a href="{{ url_for('works.review_data', work_id=work.id) }}" class="btn btn-success btn-lg px-5">
                    <i class="bi bi-table"></i> Review & Edit Extracted Data
                </a>
                <a href="{{ url_for('works.work_history') }}?work_id={{ work.id }}" class="btn btn-outline-secondary btn-lg ms-2">
                    <i class="bi bi-clock-history"></i> View History
                </a>
            </div>
        </div>
    </div>
    
    <!-- Separator -->
    <div class="text-center my-4">
        <span class="badge bg-secondary fs-6 px-4 py-2">OR</span>
    </div>
    
    <!-- Add More Files Section -->
    <div class="text-center mb-3">
        <h5 class="text-muted">
            <i class="bi bi-plus-circle"></i> Upload Additional GA Drawings
        </h5>
        <p class="small text-muted">Upload more PDF files to extract additional equipment data</p>
    </div>
    {% endif %}

    <!-- Upload Form (hide for Admin users) -->
    {% if session.user.role != 'Admin' %}
    <div class="card border-0 shadow-sm mb-4">
        <div class="card-header bg-primary text-white">
            <h5 class="mb-0"><i class="bi bi-upload"></i> Upload GA Drawing</h5>
        </div>
        <div class="card-body">
            <!-- Masterfile Status Section -->
            <div class="alert alert-info mb-4">
                <div class="d-flex align-items-center">
                    <i class="bi bi-file-earmark-excel text-success fs-3 me-3"></i>
                    <div class="flex-grow-1">
                        <h6 class="mb-1 fw-bold">Excel Masterfile</h6>
                        <div id="masterfileStatus">
                            <span class="spinner-border spinner-border-sm me-2"></span>
                            Loading masterfile status...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Upload Form -->
            <form id="uploadForm" method="POST" enctype="multipart/form-data" action="{{ url_for('works.start_extraction', work_id=work.id) }}">
                <!-- Upload Mode Switch -->
                <div class="mb-2">
                    <label class="form-label fw-bold small">
                        <i class="bi bi-layers"></i> Upload Mode
                    </label>
                    <div class="btn-group w-100" role="group" aria-label="Upload mode">
                        <input type="radio" class="btn-check" name="uploadMode" id="singleMode" value="single" checked autocomplete="off">
                        <label class="btn btn-sm btn-outline-primary" for="singleMode">
                            <i class="bi bi-file-earmark"></i> Single
                        </label>
                        
                        <input type="radio" class="btn-check" name="uploadMode" id="multipleMode" value="multiple" autocomplete="off">
                        <label class="btn btn-sm btn-outline-primary" for="multipleMode">
                            <i class="bi bi-files"></i> Multiple
                        </label>
                        
                        <input type="radio" class="btn-check" name="uploadMode" id="folderMode" value="folder" autocomplete="off">
                        <label class="btn btn-sm btn-outline-primary" for="folderMode">
                            <i class="bi bi-folder2-open"></i> Folder
                        </label>
                    </div>
                </div>

                <div class="mb-2">
                    <label for="pdfFile" class="form-label fw-bold small">
                        <i class="bi bi-file-pdf"></i> <span id="uploadLabel">Select GA Drawing PDF</span>
                    </label>
                    <input 
                        type="file" 
                        class="form-control form-control-sm" 
                        id="pdfFile" 
                        name="file" 
                        accept=".pdf,application/pdf" 
                        required
                    >
                    <div class="form-text small">
                        <i class="bi bi-info-circle"></i>
                        <span id="uploadHint">Only PDF files. Max: 50MB</span>
                    </div>
                </div>

                <!-- Selected Files Preview -->
                <div id="filePreview" class="mb-2 d-none">
                    <label class="form-label fw-bold small">Selected Files (<span id="fileCount">0</span>):</label>
                    <div id="filesList" class="list-group">
                        <!-- Files will be added here dynamically -->
                    </div>
                </div>

                <div class="mb-2">
                    <div class="alert alert-warning py-2 mb-0">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="confirmUpload" required>
                            <label class="form-check-label small" for="confirmUpload">
                                <strong>I confirm</strong> valid GA drawing PDF
                            </label>
                        </div>
                    </div>
                </div>

                <div class="d-grid gap-2">
                    <button type="submit" class="btn btn-primary" id="submitBtn">
                        <i class="bi bi-upload"></i> Start Extraction
                    </button>
                    <a href="{{ url_for('works.view_work', work_id=work.id) }}" class="btn btn-sm btn-outline-secondary">
                        <i class="bi bi-arrow-left"></i> Back to Work
                    </a>
                </div>
            </form>
        </div>
    </div>

    <!-- Extraction Progress Section (Hidden initially) -->
    <div id="extractionProgress" class="card border-0 shadow-sm mb-4" style="display: none;">
        <div class="card-header bg-primary text-white">
            <h5 class="mb-0">
                <i class="bi bi-hourglass-split"></i> Extraction in Progress
            </h5>
        </div>
        <div class="card-body">
            <!-- Status Badge -->
            <div class="mb-3">
                <h6 class="text-muted mb-2">Status</h6>
                <div id="statusBadge" class="badge bg-primary fs-6">
                    <span class="spinner-border spinner-border-sm me-2"></span>
                    <span id="statusText">PENDING</span>
                </div>
            </div>

            <!-- Progress Bar -->
            <div class="mb-3">
                <h6 class="text-muted mb-2">Overall Progress</h6>
                <div class="progress" style="height: 30px;">
                    <div 
                        id="progressBar" 
                        class="progress-bar progress-bar-striped progress-bar-animated" 
                        role="progressbar" 
                        style="width: 0%;"
                        aria-valuenow="0" 
                        aria-valuemin="0" 
                        aria-valuemax="100">
                        <span id="progressText" class="fw-bold">0%</span>
                    </div>
                </div>
                <small class="text-muted" id="pagesContainer" style="display: none;">
                    <span id="pagesProcessed">0</span> of <span id="totalPages">0</span> pages processed
                </small>
            </div>

            <!-- Extraction Log Terminal -->
            <div class="mb-3">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="text-muted mb-0">Extraction Log</h6>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
                <div id="extractionLog" class="extraction-terminal">
                    <div class="log-entry text-success">
                        <i class="bi bi-chevron-right"></i> System ready. Waiting for extraction to start...
                    </div>
                </div>
                <!-- Next Button (appears after completion) -->
                <div id="nextButtonContainer" class="d-none mt-3 text-end">
                    <a href="{{ url_for('works.review_data', work_id=work.id) }}" class="btn btn-primary btn-lg pulse-animation" id="nextToReviewBtn">
                        <i class="bi bi-arrow-right-circle"></i> Next: Review & Edit Data
                    </a>
                </div>
            </div>

            <!-- Error Display -->
            <div id="errorSection" class="alert alert-danger d-none">
                <i class="bi bi-exclamation-triangle-fill me-2"></i>
                <span id="errorText"></span>
            </div>

            <!-- Success Display -->
            <div id="successSection" class="alert alert-success d-none">
                <i class="bi bi-check-circle-fill me-2"></i>
                <strong>Extraction completed successfully!</strong> 
                <span id="equipmentCount">0</span> equipment items with components have been extracted.
            </div>
        </div>
    </div>
    {% else %}
    <!-- Admin View - No Upload -->
    <div class="alert alert-info">
        <i class="bi bi-info-circle-fill me-2"></i>
        <strong>Admin View:</strong> You can view extraction status but cannot upload files. Engineers perform extractions.
    </div>
    {% endif %}


</div>
{% endblock %}

{% block extra_css %}
<style>
    .equipment-card {
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .equipment-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 16px rgba(0,0,0,0.15) !important;
    }
    
    [data-theme="dark"] .equipment-card {
        background-color: var(--bg-secondary);
    }
    
    /* Pulse animation for Next button */
    @keyframes pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(13, 110, 253, 0.7);
        }
        70% {
            box-shadow: 0 0 0 10px rgba(13, 110, 253, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(13, 110, 253, 0);
        }
    }
    
    .pulse-animation {
        animation: pulse 2s infinite;
    }
    
    /* Terminal-style log viewer */
    .extraction-terminal {
        background-color: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Courier New', Consolas, monospace;
        font-size: 13px;
        padding: 15px;
        border-radius: 8px;
        height: 400px;
        overflow-y: auto;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
    }
    
    /* Files list preview */
    #filesList {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 4px;
    }
    
    #filesList .list-group-item {
        border: none;
        border-bottom: 1px solid #dee2e6;
    }
    
    #filesList .list-group-item:last-child {
        border-bottom: none;
    }
    
    #filesList::-webkit-scrollbar {
        width: 6px;
    }
    
    #filesList::-webkit-scrollbar-track {
        background: #f1f1f1;
    }
    
    #filesList::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 3px;
    }
    
    #filesList::-webkit-scrollbar-thumb:hover {
        background: #555;
    }
    
    [data-theme="dark"] .extraction-terminal {
        background-color: #0d1117;
        border: 1px solid #30363d;
    }
    
    .log-entry {
        margin-bottom: 4px;
        line-height: 1.5;
        word-wrap: break-word;
    }
    
    .log-entry i {
        margin-right: 5px;
    }
    
    .log-timestamp {
        color: #858585;
        margin-right: 8px;
    }
    
    /* Scrollbar styling for terminal */
    .extraction-terminal::-webkit-scrollbar {
        width: 8px;
    }
    
    .extraction-terminal::-webkit-scrollbar-track {
        background: #2d2d2d;
    }
    
    .extraction-terminal::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
    }
    
    .extraction-terminal::-webkit-scrollbar-thumb:hover {
        background: #666;
    }
</style>
{% endblock %}

{% block extra_js %}
<script>
let extractionId = null;
let pollInterval = null;
let allExtractionIds = [];  // Track all extraction IDs for multi-file uploads
let extractionProgressMap = {};  // Track progress for each extraction

// Load masterfile status on page load
document.addEventListener('DOMContentLoaded', function() {
    fetchMasterfileStatus();
    
    // Handle form submission for multiple files
    const uploadForm = document.getElementById('uploadForm');
    uploadForm.addEventListener('submit', async function(e) {
        const fileInput = document.getElementById('pdfFile');
        const files = fileInput.files;
        
        // If multiple files selected, process them sequentially
        if (files.length > 1) {
            e.preventDefault();
            
            // Reset tracking for new multi-file extraction
            allExtractionIds = [];
            extractionProgressMap = {};
            window.isMultiFileProcessing = true;
            
            addLog(`Processing ${files.length} files...`, 'info');
            document.getElementById('extractionProgress').style.display = 'block';
            document.getElementById('submitBtn').disabled = true;
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                addLog(`[${i + 1}/${files.length}] Uploading: ${file.name}`, 'processing');
                
                // Create FormData for this specific file
                const formData = new FormData();
                formData.append('file', file);
                
                try {
                    const response = await fetch(uploadForm.action, {
                        method: 'POST',
                        body: formData
                    });
                    
                    const data = await response.json();
                    
                    if (data.extraction_id) {
                        addLog(`[${i + 1}/${files.length}] Started extraction for ${file.name} (ID: ${data.extraction_id})`, 'success');
                        extractionId = data.extraction_id;
                        
                        // Add to tracking list for cumulative progress
                        allExtractionIds.push(data.extraction_id);
                        extractionProgressMap[data.extraction_id] = {
                            total_pages: 0,
                            processed_pages: 0,
                            status: 'pending'
                        };
                        
                        // Poll this extraction until complete
                        const success = await pollExtractionUntilComplete(data.extraction_id, file.name);
                        if (success) {
                            addLog(`[${i + 1}/${files.length}] ✓ Processing complete for ${file.name}`, 'success');
                        } else {
                            addLog(`[${i + 1}/${files.length}] ✗ Processing failed for ${file.name}`, 'error');
                        }
                    } else {
                        addLog(`[${i + 1}/${files.length}] Failed to start: ${file.name} - ${data.message || 'Unknown error'}`, 'error');
                    }
                } catch (error) {
                    addLog(`[${i + 1}/${files.length}] Error uploading ${file.name}: ${error.message}`, 'error');
                }
            }
            
            addLog('All files processed!', 'success');
            document.getElementById('submitBtn').disabled = false;
            
            // Clear multi-file processing flag
            window.isMultiFileProcessing = false;
            
            // Update status badge to completed now that all files are done
            const statusBadge = document.getElementById('statusBadge');
            if (statusBadge) {
                statusBadge.className = 'badge fs-6 bg-success';
                statusBadge.innerHTML = '<i class="bi bi-check-circle-fill me-2"></i> COMPLETED';
            }
            
            // Set progress to 100% on completion
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            if (progressBar) {
                progressBar.style.width = '100%';
                progressBar.setAttribute('aria-valuenow', 100);
                progressBar.classList.remove('progress-bar-animated');
            }
            if (progressText) {
                progressText.textContent = '100%';
            }
            
            // Show success section
            const successSection = document.getElementById('successSection');
            if (successSection) {
                successSection.classList.remove('d-none');
            }
            
            // Show next button after all files
            const nextButtonContainer = document.getElementById('nextButtonContainer');
            if (nextButtonContainer) {
                nextButtonContainer.classList.remove('d-none');
            }
            
            addLog('All extractions completed! Click Next to review the data.', 'info');
            
            // IMPORTANT: Return here to prevent form from submitting normally
            return;
        }
        // For single file, let the form submit normally
    });
});

// Poll extraction until complete (for multiple files)
// Aggregates progress from all tracked extraction IDs
async function pollExtractionUntilComplete(extractionId, fileName) {
    return new Promise((resolve) => {
        let previousProgress = 0;
        let pollCount = 0;
        const maxPolls = 300; // 10 minutes max (300 * 2 seconds)
        let completionLogged = false; // Prevent duplicate logs
        
        // Reset UI to show pending status for this extraction
        const statusBadge = document.getElementById('statusBadge');
        const progressBar = document.getElementById('progressBar');
        if (statusBadge) {
            statusBadge.className = 'badge fs-6 bg-secondary';
            statusBadge.innerHTML = '<i class="bi bi-hourglass-split me-2"></i> PENDING';
        }
        if (progressBar) {
            progressBar.classList.add('progress-bar-animated');
        }
        
        const checkInterval = setInterval(async () => {
            pollCount++;
            
            // Timeout after max polls
            if (pollCount > maxPolls) {
                clearInterval(checkInterval);
                addLog(`✗ Timeout: ${fileName} (exceeded 10 minutes)`, 'error');
                resolve(false);
                return;
            }
            
            try {
                const response = await fetch(`/works/extraction/${extractionId}/status`);
                const data = await response.json();
                
                console.log(`Poll ${pollCount} for ${fileName}:`, data); // Debug log
                
                // Store this extraction's progress
                extractionProgressMap[extractionId] = {
                    total_pages: data.total_pages || 0,
                    processed_pages: data.processed_pages || 0,
                    status: data.status || 'pending'
                };
                
                // ===== CALCULATE CUMULATIVE PROGRESS FROM ALL TRACKED EXTRACTIONS =====
                let totalPages = 0;
                let processedPages = 0;
                for (let id of allExtractionIds) {
                    if (extractionProgressMap[id]) {
                        totalPages += extractionProgressMap[id].total_pages || 0;
                        processedPages += extractionProgressMap[id].processed_pages || 0;
                    }
                }
                
                const cumulativeProgress = (processedPages / totalPages * 100) || 0;
                
                // Update progress bar with cumulative progress
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                const pagesProcessed = document.getElementById('pagesProcessed');
                const totalPagesEl = document.getElementById('totalPages');
                const pagesContainer = document.getElementById('pagesContainer');
                
                if (progressBar && cumulativeProgress !== previousProgress && totalPages > 0) {
                    progressBar.style.width = cumulativeProgress + '%';
                    progressBar.setAttribute('aria-valuenow', Math.round(cumulativeProgress));
                }
                if (progressText && cumulativeProgress !== previousProgress && totalPages > 0) {
                    progressText.textContent = Math.round(cumulativeProgress) + '%';
                }
                
                // Only show page counts if we have actual data
                if (totalPages > 0) {
                    if (pagesContainer) {
                        pagesContainer.style.display = 'block';
                    }
                    if (pagesProcessed) {
                        pagesProcessed.textContent = processedPages;
                    }
                    if (totalPagesEl) {
                        totalPagesEl.textContent = totalPages;
                    }
                }
                
                // Update status badge to show current status
                const statusBadge = document.getElementById('statusBadge');
                const statusText = document.getElementById('statusText');
                const status = data.status ? data.status.toLowerCase() : 'pending';
                
                if (statusBadge && (status === 'in_progress' || status === 'processing')) {
                    statusBadge.className = 'badge fs-6 bg-primary';
                    statusBadge.innerHTML = '<i class="bi bi-hourglass-split me-2"></i> PROCESSING';
                }
                if (statusText && (status === 'in_progress' || status === 'processing')) {
                    statusText.textContent = 'PROCESSING';
                }
                
                previousProgress = cumulativeProgress;
                
                // Check status - handle all possible status values
                const checkStatus = data.status ? data.status.toLowerCase() : '';
                
                if (checkStatus === 'completed' || checkStatus === 'success') {
                    clearInterval(checkInterval);
                    // Only log once
                    if (!completionLogged) {
                        addLog(`✓ Completed: ${fileName} (${data.equipment_count || 0} equipment)`, 'success');
                        completionLogged = true;
                        
                        // Log extraction completion activity
                        fetch('{{ url_for('works.log_extraction_completion') }}', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                work_id: {{ work.id }},
                                extraction_id: extractionId,
                                equipment_count: data.equipment_count || 0
                            })
                        }).catch(err => console.error('Failed to log extraction activity:', err));
                    }
                    resolve(true);
                } else if (checkStatus === 'failed' || checkStatus === 'error') {
                    clearInterval(checkInterval);
                    addLog(`✗ Failed: ${fileName} - ${data.error_message || data.message || 'Unknown error'}`, 'error');
                    resolve(false);
                } else if (checkStatus === 'pending' || checkStatus === 'in_progress' || checkStatus === 'processing') {
                    // Continue polling
                    console.log(`${fileName} status: ${checkStatus}, cumulative progress: ${cumulativeProgress.toFixed(1)}%`);
                } else {
                    // Unknown status
                    console.warn(`Unknown status for ${fileName}: ${checkStatus}`);
                }
            } catch (error) {
                clearInterval(checkInterval);
                addLog(`✗ Error polling ${fileName}: ${error.message}`, 'error');
                console.error('Polling error:', error);
                resolve(false);
            }
        }, 2000);
    });
}

// Fetch masterfile status from backend
function fetchMasterfileStatus() {
    fetch('{{ url_for("works.get_masterfile_status", work_id=work.id) }}')
        .then(response => response.json())
        .then(data => {
            console.log('Masterfile status:', data); // Debug log
            const statusDiv = document.getElementById('masterfileStatus');
            
            if (data.has_masterfile) {
                statusDiv.innerHTML = `
                    <div class="d-flex align-items-center justify-content-between">
                        <div>
                            <span class="badge bg-success me-2">
                                <i class="bi bi-check-circle"></i> Available
                            </span>
                            <strong>${data.filename || 'masterfile.xlsx'}</strong>
                        </div>
                        <small class="text-muted">Uploaded by ${data.uploaded_by || 'Admin'}</small>
                    </div>
                `;
                
                // Debug: Show sources if available
                if (data.sources) {
                    const sources = [];
                    if (data.sources.global_template) sources.push('Global Template');
                    if (data.sources.work_specific) sources.push('Work Specific');
                    if (data.sources.database) sources.push('Database');
                    
                    if (sources.length > 0) {
                        console.log('Masterfile sources:', sources.join(', '));
                    }
                }
            } else {
                statusDiv.innerHTML = `
                    <div class="text-warning">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        <strong>No masterfile uploaded yet.</strong> Please contact an administrator to upload the Excel masterfile.
                    </div>
                `;
                
                // Disable upload if no masterfile
                const submitBtn = document.getElementById('submitBtn');
                const fileInput = document.getElementById('pdfFile');
                const confirmCheckbox = document.getElementById('confirmUpload');
                
                if (submitBtn) {
                    submitBtn.disabled = true;
                    submitBtn.innerHTML = '<i class="bi bi-exclamation-circle"></i> Masterfile Required';
                }
                if (fileInput) {
                    fileInput.disabled = true;
                }
                if (confirmCheckbox) {
                    confirmCheckbox.disabled = true;
                }
                
                console.log('No masterfile found. Sources checked:', data.sources);
            }
        })
        .catch(error => {
            console.error('Error fetching masterfile status:', error);
            document.getElementById('masterfileStatus').innerHTML = `
                <div class="text-danger">
                    <i class="bi bi-x-circle me-2"></i>
                    Error loading masterfile status
                </div>
            `;
        });
}

// Update file preview when file is selected
document.getElementById('pdfFile').addEventListener('change', function(e) {
    const files = e.target.files;
    const preview = document.getElementById('filePreview');
    const filesList = document.getElementById('filesList');
    const fileCount = document.getElementById('fileCount');
    
    if (files.length > 0) {
        filesList.innerHTML = '';
        fileCount.textContent = files.length;
        
        Array.from(files).forEach((file, index) => {
            const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);
            
            const fileItem = document.createElement('div');
            fileItem.className = 'list-group-item list-group-item-action py-2 px-3';
            fileItem.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="bi bi-file-pdf text-danger fs-5 me-2"></i>
                    <div class="flex-grow-1">
                        <div class="fw-bold small">${file.name}</div>
                        <small class="text-muted">${fileSizeMB} MB</small>
                    </div>
                    <span class="badge bg-success">Ready</span>
                </div>
            `;
            filesList.appendChild(fileItem);
        });
        
        preview.classList.remove('d-none');
    } else {
        preview.classList.add('d-none');
    }
});

// Handle upload mode switching
document.querySelectorAll('input[name="uploadMode"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const fileInput = document.getElementById('pdfFile');
        const uploadLabel = document.getElementById('uploadLabel');
        const uploadHint = document.getElementById('uploadHint');
        
        if (this.value === 'single') {
            fileInput.removeAttribute('multiple');
            fileInput.removeAttribute('webkitdirectory');
            fileInput.accept = '.pdf,application/pdf';
            uploadLabel.textContent = 'Select GA Drawing PDF';
            uploadHint.textContent = 'Only PDF files. Max: 50MB';
        } else if (this.value === 'multiple') {
            fileInput.setAttribute('multiple', 'multiple');
            fileInput.removeAttribute('webkitdirectory');
            fileInput.accept = '.pdf,application/pdf';
            uploadLabel.textContent = 'Select Multiple PDFs';
            uploadHint.textContent = 'Multiple PDFs. Max 10 files, 50MB each';
        } else if (this.value === 'folder') {
            fileInput.removeAttribute('multiple');
            fileInput.setAttribute('webkitdirectory', 'webkitdirectory');
            fileInput.accept = '.pdf,application/pdf';
            uploadLabel.textContent = 'Select Folder with PDFs';
            uploadHint.textContent = 'Folder with PDFs. All files processed';
        }
        
        // Clear selected files when mode changes
        fileInput.value = '';
        document.getElementById('filePreview').classList.add('d-none');
    });
});

// Add log entry to terminal
function addLog(message, type = 'info') {
    const logContainer = document.getElementById('extractionLog');
    const timestamp = new Date().toLocaleTimeString();
    
    let colorClass = 'text-info';
    let icon = 'bi-info-circle';
    
    if (type === 'success') {
        colorClass = 'text-success';
        icon = 'bi-check-circle';
    } else if (type === 'error') {
        colorClass = 'text-danger';
        icon = 'bi-x-circle';
    } else if (type === 'warning') {
        colorClass = 'text-warning';
        icon = 'bi-exclamation-triangle';
    } else if (type === 'processing') {
        colorClass = 'text-primary';
        icon = 'bi-gear';
    }
    
    const logEntry = document.createElement('div');
    logEntry.className = `log-entry ${colorClass}`;
    logEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span><i class="bi ${icon}"></i> ${message}`;
    
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
    
    // ===== ADVANCE PROGRESS BAR WITH EACH LOG =====
    // Skip certain logs that shouldn't advance progress
    const skipLogsKeywords = ['Completed', 'Click Next', 'All extractions', 'All files'];
    const shouldSkip = skipLogsKeywords.some(keyword => message.includes(keyword));
    
    if (!shouldSkip) {
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        
        if (progressBar) {
            // Get current progress
            let currentProgress = parseFloat(progressBar.getAttribute('aria-valuenow')) || 0;
            
            // Increment by 3-5% per log (random to look natural)
            const increment = 2 + Math.random() * 3; // 2-5% per log
            let newProgress = Math.min(currentProgress + increment, 95); // Cap at 95% until actual completion
            
            // Update progress bar
            progressBar.style.width = newProgress + '%';
            progressBar.setAttribute('aria-valuenow', Math.round(newProgress));
            
            if (progressText) {
                progressText.textContent = Math.round(newProgress) + '%';
            }
        }
    }
}

// Clear log
function clearLog() {
    const logContainer = document.getElementById('extractionLog');
    logContainer.innerHTML = '<div class="log-entry text-success"><i class="bi bi-chevron-right"></i> Log cleared.</div>';
}

// Update progress
function updateProgress(data) {
    const status = data.status?.toLowerCase() || 'pending';
    const totalPages = data.total_pages || 0;
    const processedPages = data.processed_pages || 0;
    const percentage = data.progress_percent || (totalPages > 0 ? Math.round((processedPages / totalPages) * 100) : 0);
    
    console.log('Update progress:', { status, totalPages, processedPages, percentage, data }); // Debug log
    
    // Update status badge
    const statusColors = {
        'pending': 'bg-secondary',
        'converting': 'bg-warning',
        'processing': 'bg-primary',
        'in_progress': 'bg-primary',
        'completed': 'bg-success',
        'failed': 'bg-danger'
    };
    
    const statusText = document.getElementById('statusText');
    const statusBadge = document.getElementById('statusBadge');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const pagesProcessed = document.getElementById('pagesProcessed');
    const totalPagesEl = document.getElementById('totalPages');
    
    // Only update if elements exist
    if (statusText) {
        statusText.textContent = status.toUpperCase();
    }
    
    if (statusBadge) {
        statusBadge.className = 'badge fs-6 ' + (statusColors[status] || 'bg-secondary');
    }
    
    // Update progress bar
    if (progressBar) {
        progressBar.style.width = percentage + '%';
        progressBar.setAttribute('aria-valuenow', percentage);
        
        // Keep animation running if still processing (for multi-file)
        if (status === 'in_progress' || status === 'processing' || status === 'pending') {
            if (!progressBar.classList.contains('progress-bar-animated')) {
                progressBar.classList.add('progress-bar-animated');
            }
        }
    }
    
    if (progressText) {
        progressText.textContent = Math.round(percentage) + '%';
    }
    
    // Show pages container only when we have actual data
    const pagesContainer = document.getElementById('pagesContainer');
    if (totalPages > 0) {
        if (pagesContainer) {
            pagesContainer.style.display = 'block';
        }
        if (pagesProcessed) {
            pagesProcessed.textContent = processedPages;
        }
        if (totalPagesEl) {
            totalPagesEl.textContent = totalPages;
        }
    } else {
        if (pagesContainer) {
            pagesContainer.style.display = 'none';
        }
    }
    
    // Log progress updates (not on every poll, only when progress changes)
    if (status === 'converting') {
        addLog('Converting PDF pages to images...', 'processing');
    } else if ((status === 'processing' || status === 'in_progress') && processedPages > 0 && totalPages > 0) {
        // Only log when we have actual progress
        if (!window.lastLoggedProgress || window.lastLoggedProgress !== `${processedPages}/${totalPages}`) {
            addLog(`Processing page ${processedPages} of ${totalPages}...`, 'processing');
            window.lastLoggedProgress = `${processedPages}/${totalPages}`;
        }
    }
    
    // Handle completion
    if (status === 'completed') {
        // Stop polling immediately
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
        }
        
        // Skip UI updates during multi-file processing
        if (window.isMultiFileProcessing) {
            return; // Let the multi-file handler manage completion
        }
        
        // Prevent duplicate completion messages
        if (window.extractionCompleted) {
            return; // Already processed completion
        }
        window.extractionCompleted = true;
        
        // Log extraction completion activity
        fetch('{{ url_for('works.log_extraction_completion') }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                work_id: {{ work.id }},
                extraction_id: extractionId,
                equipment_count: data.equipment_count || 0
            })
        }).catch(err => console.error('Failed to log extraction activity:', err));
        
        if (statusBadge) {
            statusBadge.innerHTML = '<i class="bi bi-check-circle-fill me-2"></i> COMPLETED';
        }
        
        if (progressBar) {
            progressBar.style.width = '100%';
            progressBar.setAttribute('aria-valuenow', 100);
            progressBar.classList.remove('progress-bar-animated');
        }
        
        const progressText = document.getElementById('progressText');
        if (progressText) {
            progressText.textContent = '100%';
        }
        
        const successSection = document.getElementById('successSection');
        const equipmentCount = document.getElementById('equipmentCount');
        const nextButtonContainer = document.getElementById('nextButtonContainer');
        
        if (successSection) {
            successSection.classList.remove('d-none');
        }
        
        if (equipmentCount) {
            equipmentCount.textContent = data.equipment_count || 0;
        }
        
        // Show Next button for single file extraction
        if (nextButtonContainer) {
            nextButtonContainer.classList.remove('d-none');
            addLog(`✓ Extraction completed! ${data.equipment_count || 0} equipment items extracted.`, 'success');
            addLog('Click the Next button to review and edit component data.', 'info');
        }
    }
    
    // Handle failure
    if (status === 'failed') {
        // Stop polling immediately
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
        }
        
        // Prevent duplicate failure messages
        if (window.extractionFailed) {
            return; // Already processed failure
        }
        window.extractionFailed = true;
        
        if (statusBadge) {
            statusBadge.innerHTML = '<i class="bi bi-x-circle-fill me-2"></i> FAILED';
        }
        
        if (progressBar) {
            progressBar.classList.remove('progress-bar-animated');
            progressBar.classList.add('bg-danger');
        }
        
        const errorSection = document.getElementById('errorSection');
        const errorText = document.getElementById('errorText');
        
        if (errorSection) {
            errorSection.classList.remove('d-none');
        }
        
        if (errorText) {
            errorText.textContent = data.error_message || 'Unknown error occurred';
        }
        
        addLog('✗ Extraction failed: ' + (data.error_message || 'Unknown error'), 'error');
    }
}

// Poll for extraction status
function pollStatus() {
    if (!extractionId) {
        console.error('No extraction ID set');
        return;
    }
    
    const statusUrl = '/works/extraction/' + extractionId + '/status';
    console.log('Polling status from:', statusUrl);
    
    fetch(statusUrl)
        .then(response => {
            console.log('Status response:', response.status, response.statusText);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Status data received:', data);
            
            // Check if we got an error response
            if (data.error) {
                throw new Error(data.error);
            }
            
            // Reset error count on successful response
            window.pollErrorCount = 0;
            
            // ALWAYS update progress, even if data seems unchanged
            updateProgress(data);
        })
        .catch(error => {
            console.error('Error polling status:', error);
            
            // Only log actual errors, not null element issues
            if (error.message && !error.message.includes('null')) {
                addLog('Error fetching extraction status: ' + error.message, 'error');
            }
            
            // Don't stop polling on first error, might be temporary
            // But stop if we get too many consecutive errors
            if (!window.pollErrorCount) window.pollErrorCount = 0;
            window.pollErrorCount++;
            
            if (window.pollErrorCount > 10) {
                clearInterval(pollInterval);
                addLog('Too many errors. Stopped polling. Please refresh the page.', 'error');
                
                const errorSection = document.getElementById('errorSection');
                const errorText = document.getElementById('errorText');
                
                if (errorSection) {
                    errorSection.classList.remove('d-none');
                }
                
                if (errorText) {
                    errorText.textContent = 'Status polling failed. Please refresh the page to check extraction status.';
                }
            }
        });
}

// Handle form submission
document.getElementById('uploadForm').addEventListener('submit', function(e) {
    e.preventDefault();
    
    // Reset completion flags for new extraction
    window.extractionCompleted = false;
    window.extractionFailed = false;
    
    // Clear any existing polling interval
    if (pollInterval) {
        clearInterval(pollInterval);
        pollInterval = null;
    }
    
    const submitBtn = document.getElementById('submitBtn');
    const fileInput = document.getElementById('pdfFile');
    
    if (!fileInput.files[0]) {
        alert('Please select a PDF file');
        return;
    }
    
    // Check file size (50MB = 52428800 bytes)
    if (fileInput.files[0].size > 52428800) {
        alert('File size exceeds 50MB limit');
        return;
    }
    
    // Show progress section
    document.getElementById('extractionProgress').style.display = 'block';
    document.getElementById('extractionProgress').scrollIntoView({ behavior: 'smooth' });
    
    // Add initial logs
    addLog('Starting extraction process...', 'info');
    addLog(`File: ${fileInput.files[0].name} (${(fileInput.files[0].size / 1024 / 1024).toFixed(2)} MB)`, 'info');
    addLog(`File type: ${fileInput.files[0].type}`, 'info');
    
    // Validate file extension
    const fileName = fileInput.files[0].name.toLowerCase();
    if (!fileName.endsWith('.pdf')) {
        addLog('✗ Invalid file type. Only PDF files are accepted.', 'error');
        document.getElementById('errorSection').classList.remove('d-none');
        document.getElementById('errorText').textContent = 'Please select a PDF file (.pdf extension)';
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="bi bi-upload"></i> Start Extraction';
        return;
    }
    
    // Disable button and show loading
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Uploading...';
    
    // Create FormData
    const formData = new FormData(this);
    
    // Upload file
    addLog('Uploading PDF to server...', 'processing');
    fetch(this.action, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        // Check if response is ok (status 200-299)
        if (!response.ok) {
            return response.json().then(data => {
                throw new Error(data.error || 'Upload failed');
            });
        }
        return response.json();
    })
    .then(data => {
        if (data.extraction_id) {
            extractionId = data.extraction_id;
            window.pollErrorCount = 0; // Reset error counter
            
            addLog(`✓ PDF uploaded successfully. Extraction ID: ${extractionId}`, 'success');
            addLog('Starting AI-powered extraction...', 'processing');
            addLog('Converting PDF pages to images...', 'processing');
            
            console.log('Starting to poll for extraction ID:', extractionId);
            
            // Initialize progress display
            updateProgress({
                status: 'pending',
                total_pages: 0,
                processed_pages: 0,
                progress_percent: 0
            });
            
            // Start polling immediately
            pollStatus();
            pollInterval = setInterval(pollStatus, 2000);
        } else if (data.error) {
            addLog('✗ Upload failed: ' + data.error, 'error');
            document.getElementById('errorSection').classList.remove('d-none');
            document.getElementById('errorText').textContent = data.error;
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="bi bi-upload"></i> Start Extraction';
        } else {
            addLog('✗ Upload failed: Unknown error', 'error');
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="bi bi-upload"></i> Start Extraction';
        }
    })
    .catch(error => {
        console.error('Upload error:', error);
        addLog('✗ Upload error: ' + error.message, 'error');
        
        // Show error in UI
        document.getElementById('errorSection').classList.remove('d-none');
        document.getElementById('errorText').textContent = error.message;
        
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="bi bi-upload"></i> Start Extraction';
    });
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (pollInterval) {
        clearInterval(pollInterval);
    }
});
</script>
{% endblock %}
