{% extends 'base.html' %}

{% block title %}Extract Equipment - {{ work.name }} - AutoRBI{% endblock %}

{% block content %}
<div class="extraction-page">
    <!-- Page Header -->
    <div class="mb-4">
        <h2 class="fw-bold">
            <i class="bi bi-file-earmark-arrow-up"></i> Extract Equipment Data
        </h2>
        <p class="text-muted">Upload GA drawing PDF to extract equipment information</p>
    </div>

    <!-- Work Info -->
    <div class="alert alert-info mb-4">
        <div class="d-flex align-items-center">
            <i class="bi bi-info-circle-fill fs-4 me-3"></i>
            <div>
                <strong>Work: {{ work.name }}</strong>
                <p class="mb-0 small">Upload a GA (General Arrangement) drawing PDF file. The system will automatically
                    extract equipment data using AI. After extraction, you'll review and edit the data in table format.
                </p>
            </div>
        </div>
    </div>

    <!-- Quick Stats (if equipment exists) -->
    {% if equipment %}
    <div class="card border-0 shadow-sm mb-4 border-success" style="border-width: 2px !important;">
        <div class="card-header bg-success text-white">
            <h5 class="mb-0">
                <i class="bi bi-check-circle-fill"></i> Equipment Data Available
            </h5>
        </div>
        <div class="card-body">
            <div class="row text-center g-3">
                <div class="col-md-6">
                    <div class="stat-item">
                        <i class="bi bi-gear-fill text-primary fs-2"></i>
                        <h3 class="mb-0 mt-2">{{ equipment|length }}</h3>
                        <small class="text-muted">Equipment Items</small>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="stat-item">
                        <i class="bi bi-box text-success fs-2"></i>
                        <h3 class="mb-0 mt-2">
                            {% set total_components = namespace(count=0) %}
                            {% for equip in equipment %}
                            {% set total_components.count = total_components.count + (equip.components|length) %}
                            {% endfor %}
                            {{ total_components.count }}
                        </h3>
                        <small class="text-muted">Components Extracted</small>
                    </div>
                </div>
            </div>
            <div class="text-center mt-4">
                <a href="{{ url_for('works.review_data', work_id=work.id) }}" class="btn btn-success btn-lg px-5">
                    <i class="bi bi-table"></i> Review & Edit Extracted Data
                </a>
                <a href="{{ url_for('works.work_history') }}?work_id={{ work.id }}"
                    class="btn btn-outline-secondary btn-lg ms-2">
                    <i class="bi bi-clock-history"></i> View History
                </a>
            </div>
        </div>
    </div>

    <!-- Separator -->
    <div class="text-center my-4">
        <span class="badge bg-secondary fs-6 px-4 py-2">OR</span>
    </div>

    <!-- Add More Files Section -->
    <div class="text-center mb-3">
        <h5 class="text-muted">
            <i class="bi bi-plus-circle"></i> Upload Additional GA Drawings
        </h5>
        <p class="small text-muted">Upload more PDF files to extract additional equipment data</p>
    </div>
    {% endif %}

    <!-- Upload Form (hide for Admin users) -->
    {% if session.user.role != 'Admin' %}
    <div class="card border-0 shadow-sm mb-4">
        <div class="card-header bg-primary text-white">
            <h5 class="mb-0"><i class="bi bi-upload"></i> Upload GA Drawing</h5>
        </div>
        <div class="card-body">
            <!-- Masterfile Status Section -->
            <div class="alert alert-info mb-4">
                <div class="d-flex align-items-center">
                    <i class="bi bi-file-earmark-excel text-success fs-3 me-3"></i>
                    <div class="flex-grow-1">
                        <h6 class="mb-1 fw-bold">Excel Masterfile</h6>
                        <div id="masterfileStatus">
                            <span class="spinner-border spinner-border-sm me-2"></span>
                            Loading masterfile status...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Upload Form -->
            <form id="uploadForm" method="POST" enctype="multipart/form-data"
                action="{{ url_for('works.start_extraction', work_id=work.id) }}">
                <!-- Upload Mode Switch -->
                <div class="mb-2">
                    <label class="form-label fw-bold small">
                        <i class="bi bi-layers"></i> Upload Mode
                    </label>
                    <div class="btn-group w-100" role="group" aria-label="Upload mode">
                        <input type="radio" class="btn-check" name="uploadMode" id="singleMode" value="single" checked
                            autocomplete="off">
                        <label class="btn btn-sm btn-outline-primary" for="singleMode">
                            <i class="bi bi-file-earmark"></i> Single
                        </label>

                        <input type="radio" class="btn-check" name="uploadMode" id="multipleMode" value="multiple"
                            autocomplete="off">
                        <label class="btn btn-sm btn-outline-primary" for="multipleMode">
                            <i class="bi bi-files"></i> Multiple
                        </label>

                        <input type="radio" class="btn-check" name="uploadMode" id="folderMode" value="folder"
                            autocomplete="off">
                        <label class="btn btn-sm btn-outline-primary" for="folderMode">
                            <i class="bi bi-folder2-open"></i> Folder
                        </label>
                    </div>
                </div>

                <div class="mb-2">
                    <label for="pdfFile" class="form-label fw-bold small">
                        <i class="bi bi-file-pdf"></i> <span id="uploadLabel">Select GA Drawing PDF</span>
                    </label>
                    <input type="file" class="form-control form-control-sm" id="pdfFile" name="file"
                        accept=".pdf,application/pdf" required>
                    <div class="form-text small">
                        <i class="bi bi-info-circle"></i>
                        <span id="uploadHint">Only PDF files. Max: 50MB</span>
                    </div>
                </div>

                <!-- Selected Files Preview -->
                <div id="filePreview" class="mb-2 d-none">
                    <label class="form-label fw-bold small">Selected Files (<span id="fileCount">0</span>):</label>
                    <div id="filesList" class="list-group">
                        <!-- Files will be added here dynamically -->
                    </div>
                </div>

                <div class="mb-2">
                    <div class="alert alert-warning py-2 mb-0">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="confirmUpload" required>
                            <label class="form-check-label small" for="confirmUpload">
                                <strong>I confirm</strong> valid GA drawing PDF
                            </label>
                        </div>
                    </div>
                </div>

                <div class="d-grid gap-2">
                    <button type="submit" class="btn btn-primary" id="submitBtn">
                        <i class="bi bi-upload"></i> Start Extraction
                    </button>
                    <a href="{{ url_for('works.view_work', work_id=work.id) }}"
                        class="btn btn-sm btn-outline-secondary">
                        <i class="bi bi-arrow-left"></i> Back to Work
                    </a>
                </div>
            </form>
        </div>
    </div>

    <!-- Extraction Progress Section (Hidden initially) -->
    <div id="extractionProgress" class="card border-0 shadow-sm mb-4" style="display: none;">
        <div class="card-header bg-primary text-white">
            <h5 class="mb-0">
                <i class="bi bi-hourglass-split"></i> Extraction in Progress
            </h5>
        </div>
        <div class="card-body">
            <!-- Status Badge -->
            <div class="mb-3">
                <h6 class="text-muted mb-2">Status</h6>
                <div id="statusBadge" class="badge bg-primary fs-6">
                    <span class="spinner-border spinner-border-sm me-2"></span>
                    <span id="statusText">PENDING</span>
                </div>
            </div>

            <!-- Progress Bar -->
            <!-- Extraction Log Terminal -->
            <div class="mb-3">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="text-muted mb-0">Extraction Log</h6>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
                <div id="extractionLog" class="extraction-terminal">
                    <div class="log-entry text-success">
                        <i class="bi bi-chevron-right"></i> System ready. Waiting for extraction to start...
                    </div>
                </div>
                <!-- Next Button (appears after completion) -->
                <div id="nextButtonContainer" class="d-none mt-3 text-end">
                    <a href="{{ url_for('works.review_data', work_id=work.id) }}"
                        class="btn btn-primary btn-lg pulse-animation" id="nextToReviewBtn">
                        <i class="bi bi-arrow-right-circle"></i> Next: Review & Edit Data
                    </a>
                </div>
            </div>

            <!-- Error Display -->
            <div id="errorSection" class="alert alert-danger d-none">
                <i class="bi bi-exclamation-triangle-fill me-2"></i>
                <span id="errorText"></span>
            </div>

            <!-- Success Display -->
            <div id="successSection" class="alert alert-success d-none">
                <i class="bi bi-check-circle-fill me-2"></i>
                <strong>Extraction completed successfully!</strong>
                <span id="equipmentCount">0</span> equipment items with components have been extracted.
            </div>
        </div>
    </div>
    {% else %}
    <!-- Admin View - No Upload -->
    <div class="alert alert-info">
        <i class="bi bi-info-circle-fill me-2"></i>
        <strong>Admin View:</strong> You can view extraction status but cannot upload files. Engineers perform
        extractions.
    </div>
    {% endif %}


</div>
{% endblock %}

{% block extra_css %}
<style>
    .equipment-card {
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .equipment-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15) !important;
    }

    [data-theme="dark"] .equipment-card {
        background-color: var(--bg-secondary);
    }

    /* Pulse animation for Next button */
    @keyframes pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(13, 110, 253, 0.7);
        }

        70% {
            box-shadow: 0 0 0 10px rgba(13, 110, 253, 0);
        }

        100% {
            box-shadow: 0 0 0 0 rgba(13, 110, 253, 0);
        }
    }

    .pulse-animation {
        animation: pulse 2s infinite;
    }

    /* Terminal-style log viewer */
    .extraction-terminal {
        background-color: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Courier New', Consolas, monospace;
        font-size: 13px;
        padding: 15px;
        border-radius: 8px;
        height: 400px;
        overflow-y: auto;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
    }

    /* Files list preview */
    #filesList {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 4px;
    }

    #filesList .list-group-item {
        border: none;
        border-bottom: 1px solid #dee2e6;
    }

    #filesList .list-group-item:last-child {
        border-bottom: none;
    }

    #filesList::-webkit-scrollbar {
        width: 6px;
    }

    #filesList::-webkit-scrollbar-track {
        background: #f1f1f1;
    }

    #filesList::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 3px;
    }

    #filesList::-webkit-scrollbar-thumb:hover {
        background: #555;
    }

    [data-theme="dark"] .extraction-terminal {
        background-color: #0d1117;
        border: 1px solid #30363d;
    }

    .log-entry {
        margin-bottom: 4px;
        line-height: 1.5;
        word-wrap: break-word;
    }

    .log-entry i {
        margin-right: 5px;
    }

    .log-timestamp {
        color: #858585;
        margin-right: 8px;
    }

    /* Scrollbar styling for terminal */
    .extraction-terminal::-webkit-scrollbar {
        width: 8px;
    }

    .extraction-terminal::-webkit-scrollbar-track {
        background: #2d2d2d;
    }

    .extraction-terminal::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
    }

    .extraction-terminal::-webkit-scrollbar-thumb:hover {
        background: #666;
    }
</style>
{% endblock %}

{% block extra_js %}
<script>
    let extractionId = null;
    let pollInterval = null;
    let allExtractionIds = [];
    let extractionProgressMap = {};
    let fakeProgressIntervals = {};

    // Load masterfile status on page load
    document.addEventListener('DOMContentLoaded', function () {
        fetchMasterfileStatus();
    });

    // ============================================================================
    // âœ… PARALLEL MULTI-FILE HANDLER
    // ============================================================================
    async function handleMultiFileUpload(files) {
        // Clear any existing polling intervals from previous uploads
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
        }
        window.stopMonitoringExtractions = true;

        const submitBtn = document.getElementById('submitBtn');
        const uploadForm = document.getElementById('uploadForm');

        submitBtn.disabled = true;
        submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Uploading...';

        document.getElementById('extractionProgress').style.display = 'block';
        document.getElementById('extractionProgress').scrollIntoView({ behavior: 'smooth' });

        addLog(`Starting upload of ${files.length} files in batches...`, 'info');

        try {
            // âœ… BATCHED UPLOAD: Upload 3 files at a time with 2s delay between batches
            const BATCH_SIZE = 2;

            const fileArray = Array.from(files);
            const uploadResults = [];
            let batchNum = 0;
            const totalBatches = Math.ceil(fileArray.length / BATCH_SIZE);

            for (let i = 0; i < fileArray.length; i += BATCH_SIZE) {
                const batch = fileArray.slice(i, i + BATCH_SIZE);
                batchNum = Math.floor(i / BATCH_SIZE) + 1;

                addLog(`ðŸ“¦ Batch ${batchNum}/${totalBatches}: Uploading ${batch.length} files...`, 'info');

                // ===== STEP 1: Upload this batch =====
                const batchPromises = batch.map(file => {
                    const formData = new FormData();
                    formData.append('file', file);

                    return fetch(uploadForm.action, {
                        method: 'POST',
                        body: formData
                    })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().catch(err => ({ error: `HTTP ${response.status}` }))
                                    .then(data => { throw new Error(data.error || 'Upload failed'); });
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.extraction_id) {
                                addLog(`  âœ“ Uploaded: ${file.name} (extraction ${data.extraction_id})`, 'success');
                                return { file: file.name, id: data.extraction_id };
                            } else {
                                throw new Error(data.message || 'No extraction ID returned');
                            }
                        })
                        .catch(error => {
                            addLog(`  âœ— Failed: ${file.name} - ${error.message}`, 'error');
                            return { file: file.name, id: null, error: error.message };
                        });
                });

                // Wait for uploads to complete
                const batchResults = await Promise.all(batchPromises);
                uploadResults.push(...batchResults);

                addLog(`  âœ“ Batch ${batchNum} uploads complete`, 'success');

                // ===== STEP 2: Wait for this batch's extractions to complete =====
                const batchExtractionIds = batchResults
                    .filter(r => r.id !== null)
                    .map(r => ({ id: r.id, file: r.file }));

                if (batchExtractionIds.length > 0) {
                    addLog(`â³ Waiting for Batch ${batchNum} extractions to complete...`, 'info');
                    
                    const batchPollPromises = batchExtractionIds.map(result =>
                        pollExtractionUntilComplete(result.id, result.file)
                    );
                    
                    const batchPollResults = await Promise.all(batchPollPromises);
                    const batchSuccessCount = batchPollResults.filter(r => r === true).length;
                    const batchFailCount = batchPollResults.filter(r => r === false).length;
                    
                    addLog(`âœ… Batch ${batchNum} extractions complete: ${batchSuccessCount} succeeded, ${batchFailCount} failed`, 'success');
                }

                // Only move to next batch if there is one
                if (batchNum < totalBatches) {
                    addLog(`â±ï¸ Batch ${batchNum} done, preparing next batch...`, 'info');
                }
            }

            // All batches processed - extractions were polled during batch loop
            const successfulUploads = uploadResults.filter(r => r.id !== null);
            const failedUploads = uploadResults.filter(r => r.id === null);

            if (successfulUploads.length === 0) {
                throw new Error('All files failed to upload');
            }

            if (failedUploads.length > 0) {
                addLog(`âš ï¸  ${failedUploads.length} file(s) failed to upload`, 'error');
            }

            const extractionIds = successfulUploads.map(r => r.id);
            allExtractionIds = extractionIds;

            addLog(`âœ“ ${successfulUploads.length}/${files.length} files uploaded and extracted successfully!`, 'success');

            // Update UI
            const statusBadge = document.getElementById('statusBadge');
            if (statusBadge) {
                statusBadge.className = 'badge fs-6 bg-success';
                statusBadge.innerHTML = '<i class="bi bi-check-circle-fill me-2"></i> COMPLETED';
            }

            const successSection = document.getElementById('successSection');
            if (successSection) {
                successSection.classList.remove('d-none');
            }

            const nextButtonContainer = document.getElementById('nextButtonContainer');
            if (nextButtonContainer) {
                nextButtonContainer.classList.remove('d-none');
            }

            addLog('âœ… All files processed! Click Next to review the data.', 'success');

            // Stop any remaining polling
            window.stopMonitoringExtractions = true;

        } catch (error) {
            addLog(`âœ— Error: ${error.message}`, 'error');

            const errorSection = document.getElementById('errorSection');
            const errorText = document.getElementById('errorText');
            if (errorSection && errorText) {
                errorSection.classList.remove('d-none');
                errorText.textContent = error.message;
            }

        } finally {
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="bi bi-upload"></i> Start Extraction';
        }
    }
    // ============================================================================
    // Poll extraction until complete (works for both single and multi-file)
    // ============================================================================
    /**
     * Watch extraction via WebSocket (REAL-TIME, no polling!)
     */
    async function watchExtractionViaWebSocket(extractionId, fileName) {
        return new Promise((resolve) => {
            const token = localStorage.getItem('access_token');
            if (!token) {
                addLog(`  âœ— ${fileName}: No auth token`, 'error');
                resolve(false);
                return;
            }

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/api/ws/extractions/${extractionId}?token=${token}`;
            
            const ws = new WebSocket(wsUrl);
            let timeoutId = null;

            const setCompletionTimeout = () => {
                if (timeoutId) clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    ws.close();
                }, 600000);
            };

            ws.onopen = () => {
                addLog(`  â³ ${fileName}: Monitoring...`, 'info');
                setCompletionTimeout();
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);

                if (message.type === 'progress') {
                    const { page, total } = message;
                    extractionProgressMap[extractionId] = {
                        total_pages: total,
                        processed_pages: page,
                        status: 'in_progress'
                    };
                    if (total > 0) {
                        addLog(`  â³ ${fileName}: ${page}/${total} pages`, 'info');
                    }
                    setCompletionTimeout();

                } else if (message.type === 'completed') {
                    addLog(`  âœ“ Completed: ${fileName}`, 'success');
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve(true);

                } else if (message.type === 'error') {
                    addLog(`  âœ— Failed: ${fileName} - ${message.message}`, 'error');
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve(false);
                }
            };

            ws.onerror = () => {
                addLog(`  âš ï¸  ${fileName}: Connection error`, 'error');
                clearTimeout(timeoutId);
                resolve(false);
            };
        });
    }

    // Wrapper for backward compatibility
    async function pollExtractionUntilComplete(extractionId, fileName) {
        return watchExtractionViaWebSocket(extractionId, fileName);
    }

    // Fetch masterfile status
    function fetchMasterfileStatus() {
        fetch('{{ url_for("works.get_masterfile_status", work_id=work.id) }}')
            .then(response => response.json())
            .then(data => {
                const statusDiv = document.getElementById('masterfileStatus');

                if (data.has_masterfile) {
                    statusDiv.innerHTML = `
                    <div class="d-flex align-items-center justify-content-between">
                        <div>
                            <span class="badge bg-success me-2">
                                <i class="bi bi-check-circle"></i> Available
                            </span>
                            <strong>${data.filename || 'masterfile.xlsx'}</strong>
                        </div>
                        <small class="text-muted">Uploaded by ${data.uploaded_by || 'Admin'}</small>
                    </div>
                `;
                } else {
                    statusDiv.innerHTML = `
                    <div class="text-warning">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        <strong>No masterfile uploaded yet.</strong>
                    </div>
                `;

                    const submitBtn = document.getElementById('submitBtn');
                    const fileInput = document.getElementById('pdfFile');
                    const confirmCheckbox = document.getElementById('confirmUpload');

                    if (submitBtn) {
                        submitBtn.disabled = true;
                        submitBtn.innerHTML = '<i class="bi bi-exclamation-circle"></i> Masterfile Required';
                    }
                    if (fileInput) fileInput.disabled = true;
                    if (confirmCheckbox) confirmCheckbox.disabled = true;
                }
            })
            .catch(error => {
                console.error('Error fetching masterfile status:', error);
                document.getElementById('masterfileStatus').innerHTML = `
                <div class="text-danger">
                    <i class="bi bi-x-circle me-2"></i>
                    Error loading masterfile status
                </div>
            `;
            });
    }

    // Update file preview
    document.getElementById('pdfFile').addEventListener('change', function (e) {
        const files = e.target.files;
        const preview = document.getElementById('filePreview');
        const filesList = document.getElementById('filesList');
        const fileCount = document.getElementById('fileCount');

        if (files.length > 0) {
            filesList.innerHTML = '';
            fileCount.textContent = files.length;

            Array.from(files).forEach((file) => {
                const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);

                const fileItem = document.createElement('div');
                fileItem.className = 'list-group-item list-group-item-action py-2 px-3';
                fileItem.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="bi bi-file-pdf text-danger fs-5 me-2"></i>
                    <div class="flex-grow-1">
                        <div class="fw-bold small">${file.name}</div>
                        <small class="text-muted">${fileSizeMB} MB</small>
                    </div>
                    <span class="badge bg-success">Ready</span>
                </div>
            `;
                filesList.appendChild(fileItem);
            });

            preview.classList.remove('d-none');
        } else {
            preview.classList.add('d-none');
        }
    });

    // Handle upload mode switching
    document.querySelectorAll('input[name="uploadMode"]').forEach(radio => {
        radio.addEventListener('change', function () {
            const fileInput = document.getElementById('pdfFile');
            const uploadLabel = document.getElementById('uploadLabel');
            const uploadHint = document.getElementById('uploadHint');

            if (this.value === 'single') {
                fileInput.removeAttribute('multiple');
                fileInput.removeAttribute('webkitdirectory');
                uploadLabel.textContent = 'Select GA Drawing PDF';
                uploadHint.textContent = 'Only PDF files. Max: 50MB';
            } else if (this.value === 'multiple') {
                fileInput.setAttribute('multiple', 'multiple');
                fileInput.removeAttribute('webkitdirectory');
                uploadLabel.textContent = 'Select Multiple PDFs';
                uploadHint.textContent = 'Multiple PDFs. Max 10 files, 50MB each';
            } else if (this.value === 'folder') {
                fileInput.removeAttribute('multiple');
                fileInput.setAttribute('webkitdirectory', 'webkitdirectory');
                uploadLabel.textContent = 'Select Folder with PDFs';
                uploadHint.textContent = 'Folder with PDFs. All files processed';
            }

            fileInput.value = '';
            document.getElementById('filePreview').classList.add('d-none');
        });
    });

    // Add log entry
    function addLog(message, type = 'info') {
        const logContainer = document.getElementById('extractionLog');
        const timestamp = new Date().toLocaleTimeString();

        let colorClass = 'text-info';
        let icon = 'bi-info-circle';

        if (type === 'success') {
            colorClass = 'text-success';
            icon = 'bi-check-circle';
        } else if (type === 'error') {
            colorClass = 'text-danger';
            icon = 'bi-x-circle';
        } else if (type === 'processing') {
            colorClass = 'text-primary';
            icon = 'bi-gear';
        }

        const logEntry = document.createElement('div');
        logEntry.className = `log-entry ${colorClass}`;
        logEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span><i class="bi ${icon}"></i> ${message}`;

        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;
    }

    // Clear log
    function clearLog() {
        const logContainer = document.getElementById('extractionLog');
        logContainer.innerHTML = '<div class="log-entry text-success"><i class="bi bi-chevron-right"></i> Log cleared.</div>';
    }

    // Poll for single file extraction
    function pollStatus() {
        if (!extractionId) return;

        fetch(`/works/extraction/${extractionId}/status`)
            .then(response => {
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return response.json();
            })
            .then(data => {
                const status = (data.status || 'pending').toLowerCase();

                const statusBadge = document.getElementById('statusBadge');
                const progressBar = document.getElementById('fakeProgressBar');
                const progressText = document.getElementById('fakeProgressText');

                const percentage = data.total_pages > 0
                    ? Math.round((data.processed_pages / data.total_pages) * 100)
                    : 0;

                if (progressBar) {
                    progressBar.style.width = percentage + '%';
                    progressBar.setAttribute('aria-valuenow', percentage);
                }
                if (progressText) {
                    progressText.textContent = percentage + '%';
                }

                if (status === 'completed') {
                    clearInterval(pollInterval);

                    if (statusBadge) {
                        statusBadge.className = 'badge fs-6 bg-success';
                        statusBadge.innerHTML = '<i class="bi bi-check-circle-fill me-2"></i> COMPLETED';
                    }

                    if (progressBar) {
                        progressBar.style.width = '100%';
                        progressBar.classList.remove('progress-bar-animated');
                    }
                    if (progressText) progressText.textContent = '100%';

                    const successSection = document.getElementById('successSection');
                    if (successSection) successSection.classList.remove('d-none');

                    const nextButtonContainer = document.getElementById('nextButtonContainer');
                    if (nextButtonContainer) nextButtonContainer.classList.remove('d-none');

                    addLog(`âœ“ Extraction completed!`, 'success');

                } else if (status === 'failed') {
                    clearInterval(pollInterval);

                    if (statusBadge) {
                        statusBadge.className = 'badge fs-6 bg-danger';
                        statusBadge.innerHTML = '<i class="bi bi-x-circle-fill me-2"></i> FAILED';
                    }

                    const errorSection = document.getElementById('errorSection');
                    const errorText = document.getElementById('errorText');
                    if (errorSection) {
                        errorSection.classList.remove('d-none');
                        if (errorText) errorText.textContent = data.error_message || 'Unknown error';
                    }

                    addLog(`âœ— Extraction failed`, 'error');
                }
            })
            .catch(error => {
                console.error('Poll error:', error);
            });
    }



    /**
     * Watch single extraction via WebSocket
     */
    async function watchExtractionSingleFile(extractionId) {
        const token = localStorage.getItem('access_token');
        if (!token) {
            addLog('No auth token', 'error');
            return;
        }

        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/api/ws/extractions/${extractionId}?token=${token}`;
        
        const ws = new WebSocket(wsUrl);
        let timeoutId = null;

        const setCompletionTimeout = () => {
            if (timeoutId) clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                ws.close();
            }, 600000);
        };

        ws.onopen = () => {
            addLog('Connected to extraction monitor', 'info');
            setCompletionTimeout();
        };

        ws.onmessage = (event) => {
            const message = JSON.parse(event.data);

            if (message.type === 'progress') {
                const { page, total, percent } = message;
                const progressBar = document.querySelector('.progress-bar');
                const progressText = document.getElementById('progressText');
                
                if (total > 0) {
                    const pct = Math.round((page / total) * 100);
                    if (progressBar) progressBar.style.width = pct + '%';
                    if (progressText) progressText.textContent = pct + '%';
                    addLog(`Extracted: ${page}/${total} pages`, 'info');
                }
                setCompletionTimeout();

            } else if (message.type === 'completed') {
                const statusBadge = document.getElementById('statusBadge');
                if (statusBadge) {
                    statusBadge.className = 'badge fs-6 bg-success';
                    statusBadge.innerHTML = '<i class="bi bi-check-circle-fill me-2"></i> COMPLETED';
                }

                const progressBar = document.querySelector('.progress-bar');
                if (progressBar) progressBar.style.width = '100%';
                const progressText = document.getElementById('progressText');
                if (progressText) progressText.textContent = '100%';

                const successSection = document.getElementById('successSection');
                if (successSection) successSection.classList.remove('d-none');

                const nextButtonContainer = document.getElementById('nextButtonContainer');
                if (nextButtonContainer) nextButtonContainer.classList.remove('d-none');

                addLog(`Extraction completed!`, 'success');
                clearTimeout(timeoutId);
                ws.close();

            } else if (message.type === 'error') {
                const statusBadge = document.getElementById('statusBadge');
                if (statusBadge) {
                    statusBadge.className = 'badge fs-6 bg-danger';
                    statusBadge.innerHTML = '<i class="bi bi-x-circle-fill me-2"></i> FAILED';
                }

                const errorSection = document.getElementById('errorSection');
                const errorText = document.getElementById('errorText');
                if (errorSection) {
                    errorSection.classList.remove('d-none');
                    if (errorText) errorText.textContent = message.message || 'Unknown error';
                }

                addLog(`Extraction failed: ${message.message}`, 'error');
                clearTimeout(timeoutId);
                ws.close();
            }
        };

        ws.onerror = () => {
            addLog('Connection error', 'error');
            clearTimeout(timeoutId);
            showFallbackReviewButton();
        };
    }

    // Cleanup old polling function
    function pollStatus() {
        // WebSocket version used instead
    }


        // Fallback: Show review button even if upload failed
    // This allows users to review data that WAS successfully extracted
    function showFallbackReviewButton() {
        addLog(`ðŸ“‹ Showing Review & Edit button - check your data`, 'warning');
        
        const nextButtonContainer = document.getElementById('nextButtonContainer');
        if (nextButtonContainer) {
            nextButtonContainer.classList.remove('d-none');
        }
    }

        // Main form submission handler
    document.getElementById('uploadForm').addEventListener('submit', function (e) {
        e.preventDefault();

        window.extractionCompleted = false;
        window.extractionFailed = false;

        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
        }

        const fileInput = document.getElementById('pdfFile');
        const submitBtn = document.getElementById('submitBtn');
        const files = fileInput.files;

        if (files.length === 0) {
            alert('Please select a PDF file');
            return;
        }

        // Check file sizes
        for (let file of files) {
            if (file.size > 52428800) {
                alert(`File ${file.name} exceeds 50MB limit`);
                return;
            }
            if (!file.name.toLowerCase().endsWith('.pdf')) {
                alert(`File ${file.name} is not a PDF`);
                return;
            }
        }

        document.getElementById('extractionProgress').style.display = 'block';
        document.getElementById('extractionProgress').scrollIntoView({ behavior: 'smooth' });

        // âœ… HANDLE MULTI-FILE IN PARALLEL
        if (files.length > 1) {
            handleMultiFileUpload(files);
            return;
        }

        // Single file - use existing logic
        const file = files[0];

        addLog(`Starting extraction...`, 'info');
        addLog(`File: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`, 'info');

        submitBtn.disabled = true;
        submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Uploading...';

        const formData = new FormData(this);

        fetch(this.action, {
            method: 'POST',
            body: formData
        })
            .then(response => {
                // Handle 502 Gateway Timeout - extraction may have succeeded on backend
                if (response.status === 502) {
                    addLog(`âš ï¸ Server timeout (HTTP 502) - attempting recovery...`, 'warning');
                    return Promise.reject({ code: 502, message: 'Server timeout' });
                }
                
                if (!response.ok) {
                    return response.json().catch(err => ({ error: `HTTP ${response.status}` }))
                        .then(data => { throw new Error(data.error || 'Upload failed'); });
                }
                return response.json();
            })
            .then(data => {
                if (data.extraction_id) {
                    extractionId = data.extraction_id;

                    addLog(`âœ“ PDF uploaded. Extraction ID: ${extractionId}`, 'success');
                    addLog(`Starting AI extraction...`, 'processing');

                    watchExtractionSingleFile(extractionId);
                } else {
                    throw new Error(data.error || 'Unknown error');
                }
            })
            .catch(error => {
                // 502 timeout recovery: try to find the extraction that was created
                if (error.code === 502) {
                    addLog(`Querying server for latest extraction...`, 'info');
                    
                    // Give backend time to commit the extraction record
                    setTimeout(() => {
                        fetch(`/works/extraction/latest?work_id={{ work.id }}`)
                            .then(response => {
                                if (response.ok) return response.json();
                                throw new Error('Could not recover extraction');
                            })
                            .then(data => {
                                if (data && data.extraction_id) {
                                    extractionId = data.extraction_id;
                                    addLog(`âœ“ Recovery successful! Extraction ID: ${extractionId}`, 'success');
                                    addLog(`Monitoring extraction...`, 'processing');
                                    
                                    watchExtractionSingleFile(extractionId);
                                } else {
                                    throw new Error('Extraction not found in recovery');
                                }
                            })
                            .catch(recoveryError => {
                                addLog(`âœ— Recovery error: ${recoveryError.message}`, 'error');
                                showFallbackReviewButton();
                            });
                    }, 1000);
                } else {
                    addLog(`âœ— Upload error: ${error.message}`, 'error');
                    showFallbackReviewButton();
                }
            })
            .finally(() => {
                submitBtn.disabled = false;
                submitBtn.innerHTML = '<i class="bi bi-upload"></i> Start Extraction';
            });
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', function () {
        if (pollInterval) clearInterval(pollInterval);
        Object.values(fakeProgressIntervals).forEach(interval => clearInterval(interval));
    });
</script>
{% endblock %}